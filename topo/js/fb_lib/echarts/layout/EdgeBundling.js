define(["require","../data/KDTree","zrender/tool/vector"],function(require){function squaredDistance(a,b){a=a.array;b=b.array;var x=b[0]-a[0],y=b[1]-a[1],z=b[2]-a[2],w=b[3]-a[3];return x*x+y*y+z*z+w*w}function CoarsenedEdge(group){this.points=[group.mp0,group.mp1];this.group=group}function Edge(edge){var points=edge.points;if(points[0][1]<points[1][1]||edge instanceof CoarsenedEdge){this.array=[points[0][0],points[0][1],points[1][0],points[1][1]];this._startPoint=points[0];this._endPoint=points[1]}else{this.array=[points[1][0],points[1][1],points[0][0],points[0][1]];this._startPoint=points[1];this._endPoint=points[0]}this.ink=v2Dist(points[0],points[1]);this.edge=edge;this.group=null}function BundledEdgeGroup(){this.edgeList=[];this.mp0=v2Create();this.mp1=v2Create();this.ink=0}function EdgeBundling(){this.maxNearestEdge=6;this.maxTurningAngle=Math.PI/4;this.maxIteration=20}var KDTree=require("../data/KDTree"),vec2=require("zrender/tool/vector"),v2Create=vec2.create,v2DistSquare=vec2.distSquare,v2Dist=vec2.dist,v2Copy=vec2.copy,v2Clone=vec2.clone;Edge.prototype.getStartPoint=function(){return this._startPoint};Edge.prototype.getEndPoint=function(){return this._endPoint};BundledEdgeGroup.prototype.addEdge=function(edge){edge.group=this;this.edgeList.push(edge)};BundledEdgeGroup.prototype.removeEdge=function(edge){edge.group=null;this.edgeList.splice(this.edgeList.indexOf(edge),1)};EdgeBundling.prototype={constructor:EdgeBundling,run:function(rawEdges){function pointApproxEqual(p0,p1){return v2DistSquare(p0,p1)<1e-10}function cleanEdgePoints(edgePoints,rawEdgePoints){for(var res=[],off=0,i=0;i<edgePoints.length;i++)off>0&&pointApproxEqual(edgePoints[i],res[off-1])||(res[off++]=v2Clone(edgePoints[i]));rawEdgePoints[0]&&!pointApproxEqual(res[0],rawEdgePoints[0])&&(res=res.reverse());return res}for(var res=this._iterate(rawEdges),nIterate=0;nIterate++<this.maxIteration;){for(var coarsenedEdges=[],i=0;i<res.groups.length;i++)coarsenedEdges.push(new CoarsenedEdge(res.groups[i]));var newRes=this._iterate(coarsenedEdges);if(newRes.savedInk<=0)break;res=newRes}var newEdges=[],buildNewEdges=function(groups,fromEdgePoints){for(var newEdgePoints,i=0;i<groups.length;i++){var group=groups[i];if(group.edgeList[0]&&group.edgeList[0].edge instanceof CoarsenedEdge){for(var newGroups=[],j=0;j<group.edgeList.length;j++)newGroups.push(group.edgeList[j].edge.group);newEdgePoints=fromEdgePoints?fromEdgePoints.slice():[];newEdgePoints.unshift(group.mp0);newEdgePoints.push(group.mp1);buildNewEdges(newGroups,newEdgePoints)}else for(var j=0;j<group.edgeList.length;j++){var edge=group.edgeList[j];newEdgePoints=fromEdgePoints?fromEdgePoints.slice():[];newEdgePoints.unshift(group.mp0);newEdgePoints.push(group.mp1);newEdgePoints.unshift(edge.getStartPoint());newEdgePoints.push(edge.getEndPoint());newEdges.push({points:cleanEdgePoints(newEdgePoints,edge.edge.points),rawEdge:edge.edge})}}};buildNewEdges(res.groups);return newEdges},_iterate:function(rawEdges){for(var edges=[],groups=[],totalSavedInk=0,i=0;i<rawEdges.length;i++){var edge=new Edge(rawEdges[i]);edges.push(edge)}for(var tree=new KDTree(edges,4),nearests=[],_mp0=v2Create(),_mp1=v2Create(),_newGroupInk=0,mp0=v2Create(),mp1=v2Create(),newGroupInk=0,i=0;i<edges.length;i++){var edge=edges[i];if(!edge.group){tree.nearestN(edge,this.maxNearestEdge,squaredDistance,nearests);for(var maxSavedInk=0,mostSavingInkEdge=null,lastCheckedGroup=null,j=0;j<nearests.length;j++){var nearest=nearests[j],savedInk=0;if(nearest.group){if(nearest.group!==lastCheckedGroup){lastCheckedGroup=nearest.group;_newGroupInk=this._calculateGroupEdgeInk(nearest.group,edge,_mp0,_mp1);savedInk=nearest.group.ink+edge.ink-_newGroupInk}}else{_newGroupInk=this._calculateEdgeEdgeInk(edge,nearest,_mp0,_mp1);savedInk=nearest.ink+edge.ink-_newGroupInk}if(savedInk>maxSavedInk){maxSavedInk=savedInk;mostSavingInkEdge=nearest;v2Copy(mp1,_mp1);v2Copy(mp0,_mp0);newGroupInk=_newGroupInk}}if(mostSavingInkEdge){totalSavedInk+=maxSavedInk;var group;if(!mostSavingInkEdge.group){group=new BundledEdgeGroup;groups.push(group);group.addEdge(mostSavingInkEdge)}group=mostSavingInkEdge.group;v2Copy(group.mp0,mp0);v2Copy(group.mp1,mp1);group.ink=newGroupInk;mostSavingInkEdge.group.addEdge(edge)}else{var group=new BundledEdgeGroup;groups.push(group);v2Copy(group.mp0,edge.getStartPoint());v2Copy(group.mp1,edge.getEndPoint());group.ink=edge.ink;group.addEdge(edge)}}}return{groups:groups,edges:edges,savedInk:totalSavedInk}},_calculateEdgeEdgeInk:function(){var startPointSet=[],endPointSet=[];return function(e0,e1,mp0,mp1){startPointSet[0]=e0.getStartPoint();startPointSet[1]=e1.getStartPoint();endPointSet[0]=e0.getEndPoint();endPointSet[1]=e1.getEndPoint();this._calculateMeetPoints(startPointSet,endPointSet,mp0,mp1);var ink=v2Dist(startPointSet[0],mp0)+v2Dist(mp0,mp1)+v2Dist(mp1,endPointSet[0])+v2Dist(startPointSet[1],mp0)+v2Dist(mp1,endPointSet[1]);return ink}}(),_calculateGroupEdgeInk:function(group,edgeTryAdd,mp0,mp1){for(var startPointSet=[],endPointSet=[],i=0;i<group.edgeList.length;i++){var edge=group.edgeList[i];startPointSet.push(edge.getStartPoint());endPointSet.push(edge.getEndPoint())}startPointSet.push(edgeTryAdd.getStartPoint());endPointSet.push(edgeTryAdd.getEndPoint());this._calculateMeetPoints(startPointSet,endPointSet,mp0,mp1);for(var ink=v2Dist(mp0,mp1),i=0;i<startPointSet.length;i++)ink+=v2Dist(startPointSet[i],mp0)+v2Dist(endPointSet[i],mp1);return ink},_calculateMeetPoints:function(){var cp0=v2Create(),cp1=v2Create();return function(startPointSet,endPointSet,mp0,mp1){vec2.set(cp0,0,0);vec2.set(cp1,0,0);for(var len=startPointSet.length,i=0;len>i;i++)vec2.add(cp0,cp0,startPointSet[i]);vec2.scale(cp0,cp0,1/len);len=endPointSet.length;for(var i=0;len>i;i++)vec2.add(cp1,cp1,endPointSet[i]);vec2.scale(cp1,cp1,1/len);this._limitTurningAngle(startPointSet,cp0,cp1,mp0);this._limitTurningAngle(endPointSet,cp1,cp0,mp1)}}(),_limitTurningAngle:function(){var v10=v2Create(),vTmp=v2Create(),project=v2Create(),tmpOut=v2Create();return function(pointSet,p0,p1,out){var maxTurningAngleCos=Math.cos(this.maxTurningAngle),maxTurningAngleTan=Math.tan(this.maxTurningAngle);vec2.sub(v10,p0,p1);vec2.normalize(v10,v10);vec2.copy(out,p0);for(var maxMovement=0,i=0;i<pointSet.length;i++){var p=pointSet[i];vec2.sub(vTmp,p,p0);var len=vec2.len(vTmp);vec2.scale(vTmp,vTmp,1/len);var turningAngleCos=vec2.dot(vTmp,v10);if(maxTurningAngleCos>turningAngleCos){vec2.scaleAndAdd(project,p0,v10,len*turningAngleCos);var distance=v2Dist(project,p),d=distance/maxTurningAngleTan;vec2.scaleAndAdd(tmpOut,project,v10,-d);var movement=v2DistSquare(tmpOut,p0);if(movement>maxMovement){maxMovement=movement;vec2.copy(out,tmpOut)}}}}}()};return EdgeBundling});